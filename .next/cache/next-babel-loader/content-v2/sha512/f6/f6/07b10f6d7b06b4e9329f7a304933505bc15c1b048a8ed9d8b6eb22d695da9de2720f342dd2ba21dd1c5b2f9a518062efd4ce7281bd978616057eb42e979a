{"ast":null,"code":"import { EventDispatcher, MOUSE, Quaternion, Vector2, Vector3 } from 'three/build/three.module';\nconst _changeEvent = {\n  type: 'change'\n};\nconst _startEvent = {\n  type: 'start'\n};\nconst _endEvent = {\n  type: 'end'\n};\n\nclass TrackballControls extends EventDispatcher {\n  constructor(object, domElement) {\n    super();\n    if (domElement === undefined) console.warn('THREE.TrackballControls: The second parameter \"domElement\" is now mandatory.');\n    if (domElement === document) console.error('THREE.TrackballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n    const scope = this;\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      ZOOM: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_ZOOM_PAN: 4\n    };\n    this.object = object;\n    this.domElement = domElement; // API\n\n    this.enabled = true;\n    this.screen = {\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0\n    };\n    this.rotateSpeed = 1.0;\n    this.zoomSpeed = 1.2;\n    this.panSpeed = 0.3;\n    this.noRotate = false;\n    this.noZoom = false;\n    this.noPan = false;\n    this.staticMoving = false;\n    this.dynamicDampingFactor = 0.2;\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.keys = ['KeyA'\n    /*A*/\n    , 'KeyS'\n    /*S*/\n    , 'KeyD'\n    /*D*/\n    ];\n    this.mouseButtons = {\n      LEFT: MOUSE.ROTATE,\n      MIDDLE: MOUSE.DOLLY,\n      RIGHT: MOUSE.PAN\n    }; // internals\n\n    this.target = new Vector3();\n    const EPS = 0.000001;\n    const lastPosition = new Vector3();\n    let lastZoom = 1;\n    let _state = STATE.NONE,\n        _keyState = STATE.NONE,\n        _touchZoomDistanceStart = 0,\n        _touchZoomDistanceEnd = 0,\n        _lastAngle = 0;\n\n    const _eye = new Vector3(),\n          _movePrev = new Vector2(),\n          _moveCurr = new Vector2(),\n          _lastAxis = new Vector3(),\n          _zoomStart = new Vector2(),\n          _zoomEnd = new Vector2(),\n          _panStart = new Vector2(),\n          _panEnd = new Vector2(); // for reset\n\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.up0 = this.object.up.clone();\n    this.zoom0 = this.object.zoom; // methods\n\n    this.handleResize = function () {\n      const box = scope.domElement.getBoundingClientRect(); // adjustments come from similar code in the jquery offset() function\n\n      const d = scope.domElement.ownerDocument.documentElement;\n      scope.screen.left = box.left + window.pageXOffset - d.clientLeft;\n      scope.screen.top = box.top + window.pageYOffset - d.clientTop;\n      scope.screen.width = box.width;\n      scope.screen.height = box.height;\n    };\n\n    const getMouseOnScreen = function () {\n      const vector = new Vector2();\n      return function getMouseOnScreen(pageX, pageY) {\n        vector.set((pageX - scope.screen.left) / scope.screen.width, (pageY - scope.screen.top) / scope.screen.height);\n        return vector;\n      };\n    }();\n\n    const getMouseOnCircle = function () {\n      const vector = new Vector2();\n      return function getMouseOnCircle(pageX, pageY) {\n        vector.set((pageX - scope.screen.width * 0.5 - scope.screen.left) / (scope.screen.width * 0.5), (scope.screen.height + 2 * (scope.screen.top - pageY)) / scope.screen.width // screen.width intentional\n        );\n        return vector;\n      };\n    }();\n\n    this.rotateCamera = function () {\n      const axis = new Vector3(),\n            quaternion = new Quaternion(),\n            eyeDirection = new Vector3(),\n            objectUpDirection = new Vector3(),\n            objectSidewaysDirection = new Vector3(),\n            moveDirection = new Vector3();\n      return function rotateCamera() {\n        moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);\n        let angle = moveDirection.length();\n\n        if (angle) {\n          _eye.copy(scope.object.position).sub(scope.target);\n\n          eyeDirection.copy(_eye).normalize();\n          objectUpDirection.copy(scope.object.up).normalize();\n          objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();\n          objectUpDirection.setLength(_moveCurr.y - _movePrev.y);\n          objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);\n          moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));\n          axis.crossVectors(moveDirection, _eye).normalize();\n          angle *= scope.rotateSpeed;\n          quaternion.setFromAxisAngle(axis, angle);\n\n          _eye.applyQuaternion(quaternion);\n\n          scope.object.up.applyQuaternion(quaternion);\n\n          _lastAxis.copy(axis);\n\n          _lastAngle = angle;\n        } else if (!scope.staticMoving && _lastAngle) {\n          _lastAngle *= Math.sqrt(1.0 - scope.dynamicDampingFactor);\n\n          _eye.copy(scope.object.position).sub(scope.target);\n\n          quaternion.setFromAxisAngle(_lastAxis, _lastAngle);\n\n          _eye.applyQuaternion(quaternion);\n\n          scope.object.up.applyQuaternion(quaternion);\n        }\n\n        _movePrev.copy(_moveCurr);\n      };\n    }();\n\n    this.zoomCamera = function () {\n      let factor;\n\n      if (_state === STATE.TOUCH_ZOOM_PAN) {\n        factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\n        _touchZoomDistanceStart = _touchZoomDistanceEnd;\n\n        if (scope.object.isPerspectiveCamera) {\n          _eye.multiplyScalar(factor);\n        } else if (scope.object.isOrthographicCamera) {\n          scope.object.zoom *= factor;\n          scope.object.updateProjectionMatrix();\n        } else {\n          console.warn('THREE.TrackballControls: Unsupported camera type');\n        }\n      } else {\n        factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * scope.zoomSpeed;\n\n        if (factor !== 1.0 && factor > 0.0) {\n          if (scope.object.isPerspectiveCamera) {\n            _eye.multiplyScalar(factor);\n          } else if (scope.object.isOrthographicCamera) {\n            scope.object.zoom /= factor;\n            scope.object.updateProjectionMatrix();\n          } else {\n            console.warn('THREE.TrackballControls: Unsupported camera type');\n          }\n        }\n\n        if (scope.staticMoving) {\n          _zoomStart.copy(_zoomEnd);\n        } else {\n          _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;\n        }\n      }\n    };\n\n    this.panCamera = function () {\n      const mouseChange = new Vector2(),\n            objectUp = new Vector3(),\n            pan = new Vector3();\n      return function panCamera() {\n        mouseChange.copy(_panEnd).sub(_panStart);\n\n        if (mouseChange.lengthSq()) {\n          if (scope.object.isOrthographicCamera) {\n            const scale_x = (scope.object.right - scope.object.left) / scope.object.zoom / scope.domElement.clientWidth;\n            const scale_y = (scope.object.top - scope.object.bottom) / scope.object.zoom / scope.domElement.clientWidth;\n            mouseChange.x *= scale_x;\n            mouseChange.y *= scale_y;\n          }\n\n          mouseChange.multiplyScalar(_eye.length() * scope.panSpeed);\n          pan.copy(_eye).cross(scope.object.up).setLength(mouseChange.x);\n          pan.add(objectUp.copy(scope.object.up).setLength(mouseChange.y));\n          scope.object.position.add(pan);\n          scope.target.add(pan);\n\n          if (scope.staticMoving) {\n            _panStart.copy(_panEnd);\n          } else {\n            _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(scope.dynamicDampingFactor));\n          }\n        }\n      };\n    }();\n\n    this.checkDistances = function () {\n      if (!scope.noZoom || !scope.noPan) {\n        if (_eye.lengthSq() > scope.maxDistance * scope.maxDistance) {\n          scope.object.position.addVectors(scope.target, _eye.setLength(scope.maxDistance));\n\n          _zoomStart.copy(_zoomEnd);\n        }\n\n        if (_eye.lengthSq() < scope.minDistance * scope.minDistance) {\n          scope.object.position.addVectors(scope.target, _eye.setLength(scope.minDistance));\n\n          _zoomStart.copy(_zoomEnd);\n        }\n      }\n    };\n\n    this.update = function () {\n      _eye.subVectors(scope.object.position, scope.target);\n\n      if (!scope.noRotate) {\n        scope.rotateCamera();\n      }\n\n      if (!scope.noZoom) {\n        scope.zoomCamera();\n      }\n\n      if (!scope.noPan) {\n        scope.panCamera();\n      }\n\n      scope.object.position.addVectors(scope.target, _eye);\n\n      if (scope.object.isPerspectiveCamera) {\n        scope.checkDistances();\n        scope.object.lookAt(scope.target);\n\n        if (lastPosition.distanceToSquared(scope.object.position) > EPS) {\n          scope.dispatchEvent(_changeEvent);\n          lastPosition.copy(scope.object.position);\n        }\n      } else if (scope.object.isOrthographicCamera) {\n        scope.object.lookAt(scope.target);\n\n        if (lastPosition.distanceToSquared(scope.object.position) > EPS || lastZoom !== scope.object.zoom) {\n          scope.dispatchEvent(_changeEvent);\n          lastPosition.copy(scope.object.position);\n          lastZoom = scope.object.zoom;\n        }\n      } else {\n        console.warn('THREE.TrackballControls: Unsupported camera type');\n      }\n    };\n\n    this.reset = function () {\n      _state = STATE.NONE;\n      _keyState = STATE.NONE;\n      scope.target.copy(scope.target0);\n      scope.object.position.copy(scope.position0);\n      scope.object.up.copy(scope.up0);\n      scope.object.zoom = scope.zoom0;\n      scope.object.updateProjectionMatrix();\n\n      _eye.subVectors(scope.object.position, scope.target);\n\n      scope.object.lookAt(scope.target);\n      scope.dispatchEvent(_changeEvent);\n      lastPosition.copy(scope.object.position);\n      lastZoom = scope.object.zoom;\n    }; // listeners\n\n\n    function onPointerDown(event) {\n      if (scope.enabled === false) return;\n\n      switch (event.pointerType) {\n        case 'mouse':\n        case 'pen':\n          onMouseDown(event);\n          break;\n        // TODO touch\n      }\n    }\n\n    function onPointerMove(event) {\n      if (scope.enabled === false) return;\n\n      switch (event.pointerType) {\n        case 'mouse':\n        case 'pen':\n          onMouseMove(event);\n          break;\n        // TODO touch\n      }\n    }\n\n    function onPointerUp(event) {\n      if (scope.enabled === false) return;\n\n      switch (event.pointerType) {\n        case 'mouse':\n        case 'pen':\n          onMouseUp(event);\n          break;\n        // TODO touch\n      }\n    }\n\n    function keydown(event) {\n      if (scope.enabled === false) return;\n      window.removeEventListener('keydown', keydown);\n\n      if (_keyState !== STATE.NONE) {\n        return;\n      } else if (event.code === scope.keys[STATE.ROTATE] && !scope.noRotate) {\n        _keyState = STATE.ROTATE;\n      } else if (event.code === scope.keys[STATE.ZOOM] && !scope.noZoom) {\n        _keyState = STATE.ZOOM;\n      } else if (event.code === scope.keys[STATE.PAN] && !scope.noPan) {\n        _keyState = STATE.PAN;\n      }\n    }\n\n    function keyup() {\n      if (scope.enabled === false) return;\n      _keyState = STATE.NONE;\n      window.addEventListener('keydown', keydown);\n    }\n\n    function onMouseDown(event) {\n      event.preventDefault();\n\n      if (_state === STATE.NONE) {\n        switch (event.button) {\n          case scope.mouseButtons.LEFT:\n            _state = STATE.ROTATE;\n            break;\n\n          case scope.mouseButtons.MIDDLE:\n            _state = STATE.ZOOM;\n            break;\n\n          case scope.mouseButtons.RIGHT:\n            _state = STATE.PAN;\n            break;\n\n          default:\n            _state = STATE.NONE;\n        }\n      }\n\n      const state = _keyState !== STATE.NONE ? _keyState : _state;\n\n      if (state === STATE.ROTATE && !scope.noRotate) {\n        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n\n        _movePrev.copy(_moveCurr);\n      } else if (state === STATE.ZOOM && !scope.noZoom) {\n        _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\n        _zoomEnd.copy(_zoomStart);\n      } else if (state === STATE.PAN && !scope.noPan) {\n        _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\n        _panEnd.copy(_panStart);\n      }\n\n      scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);\n      scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\n      scope.dispatchEvent(_startEvent);\n    }\n\n    function onMouseMove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      const state = _keyState !== STATE.NONE ? _keyState : _state;\n\n      if (state === STATE.ROTATE && !scope.noRotate) {\n        _movePrev.copy(_moveCurr);\n\n        _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n      } else if (state === STATE.ZOOM && !scope.noZoom) {\n        _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n      } else if (state === STATE.PAN && !scope.noPan) {\n        _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n      }\n    }\n\n    function onMouseUp(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n      _state = STATE.NONE;\n      scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);\n      scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n      scope.dispatchEvent(_endEvent);\n    }\n\n    function mousewheel(event) {\n      if (scope.enabled === false) return;\n      if (scope.noZoom === true) return;\n      event.preventDefault();\n\n      switch (event.deltaMode) {\n        case 2:\n          // Zoom in pages\n          _zoomStart.y -= event.deltaY * 0.025;\n          break;\n\n        case 1:\n          // Zoom in lines\n          _zoomStart.y -= event.deltaY * 0.01;\n          break;\n\n        default:\n          // undefined, 0, assume pixels\n          _zoomStart.y -= event.deltaY * 0.00025;\n          break;\n      }\n\n      scope.dispatchEvent(_startEvent);\n      scope.dispatchEvent(_endEvent);\n    }\n\n    function touchstart(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n\n      switch (event.touches.length) {\n        case 1:\n          _state = STATE.TOUCH_ROTATE;\n\n          _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\n          _movePrev.copy(_moveCurr);\n\n          break;\n\n        default:\n          // 2 or more\n          _state = STATE.TOUCH_ZOOM_PAN;\n          const dx = event.touches[0].pageX - event.touches[1].pageX;\n          const dy = event.touches[0].pageY - event.touches[1].pageY;\n          _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n          const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n          const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\n          _panStart.copy(getMouseOnScreen(x, y));\n\n          _panEnd.copy(_panStart);\n\n          break;\n      }\n\n      scope.dispatchEvent(_startEvent);\n    }\n\n    function touchmove(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n\n      switch (event.touches.length) {\n        case 1:\n          _movePrev.copy(_moveCurr);\n\n          _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\n          break;\n\n        default:\n          // 2 or more\n          const dx = event.touches[0].pageX - event.touches[1].pageX;\n          const dy = event.touches[0].pageY - event.touches[1].pageY;\n          _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n          const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n          const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\n          _panEnd.copy(getMouseOnScreen(x, y));\n\n          break;\n      }\n    }\n\n    function touchend(event) {\n      if (scope.enabled === false) return;\n\n      switch (event.touches.length) {\n        case 0:\n          _state = STATE.NONE;\n          break;\n\n        case 1:\n          _state = STATE.TOUCH_ROTATE;\n\n          _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\n          _movePrev.copy(_moveCurr);\n\n          break;\n      }\n\n      scope.dispatchEvent(_endEvent);\n    }\n\n    function contextmenu(event) {\n      if (scope.enabled === false) return;\n      event.preventDefault();\n    }\n\n    this.dispose = function () {\n      scope.domElement.removeEventListener('contextmenu', contextmenu);\n      scope.domElement.removeEventListener('pointerdown', onPointerDown);\n      scope.domElement.removeEventListener('wheel', mousewheel);\n      scope.domElement.removeEventListener('touchstart', touchstart);\n      scope.domElement.removeEventListener('touchend', touchend);\n      scope.domElement.removeEventListener('touchmove', touchmove);\n      scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);\n      scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n      window.removeEventListener('keydown', keydown);\n      window.removeEventListener('keyup', keyup);\n    };\n\n    this.domElement.addEventListener('contextmenu', contextmenu);\n    this.domElement.addEventListener('pointerdown', onPointerDown);\n    this.domElement.addEventListener('wheel', mousewheel, {\n      passive: false\n    });\n    this.domElement.addEventListener('touchstart', touchstart, {\n      passive: false\n    });\n    this.domElement.addEventListener('touchend', touchend);\n    this.domElement.addEventListener('touchmove', touchmove, {\n      passive: false\n    });\n    this.domElement.ownerDocument.addEventListener('pointermove', onPointerMove);\n    this.domElement.ownerDocument.addEventListener('pointerup', onPointerUp);\n    window.addEventListener('keydown', keydown);\n    window.addEventListener('keyup', keyup);\n    this.handleResize(); // force an update at start\n\n    this.update();\n  }\n\n}\n\nexport { TrackballControls };","map":null,"metadata":{},"sourceType":"module"}